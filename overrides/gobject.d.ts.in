
export class Interface {
  static _classInit: (klass: any) => any;
  __name__: string;
  _construct: (params: any, ...otherArgs: any[]) => any;
  _init: (params: any) => void;
  $gtype?: GType;
}

export interface SignalMatch {
  signalId: string;
  detail: string;
  func: Function;
}

export function signal_connect(object: Object, name: string, handler: Function): number;
export function signal_connect_after(object: Object, name: string, handler: Function): number;
export function signal_emit_by_name(object: Object, name: string, ...args: any[]): void;

export let __gtkCssName__: symbol;
export let __gtkTemplate__: symbol;
export let __gtkChildren__: symbol;
export let __gtkInternalChildren__: symbol;

// Expose GObject static properties for ES6 classes

export let GTypeName: symbol;
export let requires: symbol;
export let interfaces: symbol;
export let properties: symbol;
export let signals: symbol;

export enum AccumulatorType {
  NONE,
  FIRST_WINS,
  TRUE_HANDLED
}

export class NotImplementedError extends Error {
}

export let gtypeNameBasedOnJSPath: boolean;

export let TYPE_BOOLEAN: GType<boolean>;
export let Boolean: BooleanConstructor;

export let TYPE_ENUM: GType<number>;
export let TYPE_FLAGS: GType<number>;

export let TYPE_DOUBLE: GType<number>;
export let Double: NumberConstructor;

export let TYPE_STRING: GType<string>;
export let String: StringConstructor;

declare global {
  interface BooleanConstructor {
    $gtype: GType<boolean>;
  }

  interface NumberConstructor {
    $gtype: GType<number>;
  }

  interface StringConstructor {
    $gtype: GType<string>;
  }
}

export let TYPE_NONE: GType<undefined>;
export let TYPE_POINTER: GType<undefined>;
export let TYPE_BOXED: GType<unknown>;
export let TYPE_PARAM: GType<unknown>;
export let TYPE_INTERFACE: GType<unknown>;
export let TYPE_OBJECT: GType<object>;
export let TYPE_VARIANT: GType<GLib.Variant>;
export let TYPE_INT: GType<number>;
export let TYPE_UINT: GType<number>;
export let TYPE_INT64: GType<number>;
export let TYPE_UINT64: GType<number>;
export function registerClass<
  K,
  P extends { _init(...args: K[]): void },
  T extends { prototype: P }
>(
  klass: T
): {
  $gtype: GType<T>;
  new(...args: Parameters<T["prototype"]["_init"]>): T["prototype"];
  prototype: T["prototype"];
};

export type Property<K extends ParamSpec> = K extends ParamSpecBoolean
  ? boolean
  : K extends ParamSpecDouble | ParamSpecInt | ParamSpecUInt | ParamSpecFloat | ParamSpecLong
  ? number
  : K extends ParamSpecInt64 | ParamSpecUInt64 | ParamSpecULong
  ? number
  : K extends ParamSpecFlags
  ? number
  : K extends ParamSpecString | ParamSpecUnichar
  ? string
  : K extends ParamSpecValueArray
  ? any[]
  : K extends ParamSpecObject<infer T>
  ? T
  : K extends ParamSpecEnum<infer E>
  ? E
  : K extends ParamSpecBoxed<infer B>
  ? B
  : K extends ParamSpecVariant
  ? GLib.Variant
  : any;

export type Properties<
  Properties extends { [key: string]: ParamSpec }
  > = {
    [key in keyof Properties]: Property<Properties[key]>;
  };

export type SignalDefinition = {
  param_types?: GType[];
  [key: string]: any;
};

type RegisteredClass<K,
  P extends { _init(...args: K[]): void },
  T extends { prototype: P },
  Props extends { [key: string]: ParamSpec }> = {
    $gtype: GType<RegisteredClass<K, P, T, Props>>;
    new(...args: Parameters<T["prototype"]["_init"]>): T["prototype"] & Properties<Props>;
    prototype: T["prototype"] & Properties<Props>;
  };

export function registerClass<
  K,
  P extends { _init(...args: K[]): void },
  T extends { prototype: P },
  Props extends { [key: string]: ParamSpec },
  Sigs extends {
    [key: string]: {
      param_types?: GType[];
      [key: string]: any;
    }
  }
>(
  options: {
    GTypeName?: string;
    GTypeFlags?: TypeFlags;
    Properties?: Props;
    Signals?: Sigs;
    Implements?: any[];
    CssName?: string;
    Template?: string;
    Children?: string[];
    InternalChildren?: string[];
  },
  klass: T
): RegisteredClass<K, P, T, Props>;
